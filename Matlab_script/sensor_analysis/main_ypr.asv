%% Description
% Script in which are evaluated:
%
%	1_ angle between local magnetic field and acceleration vectors (with
%	the hypotesis that only gravity field occurs, because turtles movement
%	are much slow with respect to gravity magnitude, so we expect their
%	proper accelerations along 3 axis will be negligible w.r.t. g).
%
%	2_ Yaw Pitch and Roll angles in order to evaluate turtles orientation.

% Logger was located on turtles' carapace

%	UPDATE: use filtered values of acc measures in order to keep only low
%	frequency components, corresponding to static acceleration (gravity)

%% Local magnetic field extrapulation from online dataset in NED ref. frame

% chosen an indicative point to compute magnetic field, local space and
% time variability is very low so we decides to adopt the same one for
% every turtles and every days. (If necessary, you can select day and
% position from each turtle dataset)

% Turchia
height	= 0;
lat		= 36.6060000; % from satellite info about turtles patterns
long	= 28.8150000; % from satellite info about turtles patterns
year	= 2023;
month	= 5;
day		= 30;
model	= '2020';
	
% local magnetic field from online dataset (NED frame)
% Results have nanoTesla magnitude
[XYZ, H, D, I, F] = wrldmagm(height, lat, long, decyear(year, month, day), model);

% Sensors data have microTesla magnitude, so we bring all measures
% expressed in microTesla by dividing the first one by 1000
XYZ_micro = XYZ./1000;
H_micro = H/1000;		% horizontal plane intensity (magnitude)
F_micro = F/1000;		% total intensity (magnitude)

%% angle g_mf using NED values from online dataset
% angle between g and magnetic field evaluated using NED values ​​obtained
% from online database. We use normalized vectors, we are only interested
% in directions.

% normalized vector
XYZ_m_norm = XYZ_micro/norm(XYZ_micro);
% XYZ_m_norm = XYZ_micro/F_micro;	è uguale a sopra, F_micro è il modulo del campo magnetico

acc_NED = [0 0 1];

% % NED con N che punta al nord magnetico, vediamo E nulla
% XYZ_m_mag = rotz(-D, 'deg') * XYZ_micro;
% XYZ_m_mag_norm = XYZ_m_mag/norm(XYZ_m_mag);

% angle evaluation: we would like to obtain this value also using logger
% collected data.
[angle_c_NED, angle_s_NED, angle_tn_NED]= angle_g_mf(acc_NED, XYZ_m_norm');
% angle_g_mf_NED = 90 - I;  should be the same as previously computed one,
% check 'angle_g_mf' script correctly works.

%% extrapolates raw sensor data of the selected dataset
% original and rotated acc and mag vectors. Accelerometers and Magnetic
% field sensor have not the same local frame:
%	Accelerometer:	x along turtle direction (-)
%					z down directed
%					y in order to obtain a right frame
% note: this is not a right hand reference frame

%	Magnetometer:	y along turtle direction (+)
%					z down directed
%					x in order to obtain a right frame

% Rotated sensor measure are measure of both acc and mag expressed using a
% local frame that allow us to obtain YPR values directly referred to NED
% navigation frame:

% new local frame:	x along turtle direction
%					z down directed
%					y in order to obtain a right frame

%% Norm computation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
fprintf('norm_acc_mg using rotated sensor measures \n')
[norm_acc_reor, acc_norm_reor, norm_mag_reor, mag_norm_reor, norm_gyro_reor, gyro_norm_reor] = norm_acc_mg(acc_reor, mag_reor, gyro_reor);

if isnan(acc_norm_reor(end, 1))
	acc_norm_reor(end, 1) = 0;
end

if isnan(acc_norm_reor(end, 2))
	acc_norm_reor(end, 2) = 0;
end

if isnan(acc_norm_reor(end, 3))
	acc_norm_reor(end, 3) = 0;
end

%% NOTE: angle between g and mf and YPR angles computed with sensors data
% evaluation of the validity of the method by checking if the angle between
% the magnetic field and the gravitational field can be considered as a
% constant of the problem.

% Adopted 'rotated' data, rotated as they were collected with a
% logger having z axis along down direction and x axis along
% turtle motion direction.


% accelerometer - gravity field will be seen as [0 0 g]^T if accelerometer
%					has z axis along down direction
	%% angle g_mf using reoriented collected data from loggers

	% z axis along down (NED)
fprintf('angle_g_mf using rotated sensor measures \n')
[angle_c_2, angle_s_2, angle_tn_2]= angle_g_mf(acc_reor, mag_reor);
fprintf('angle_g_mf using rotated sensor measures once divided by their norm \n')
[angle_c_2norm, angle_s_2norm, angle_tn_2norm]= angle_g_mf(acc_norm_reor, mag_norm_reor);

	%% YPR computation
		%% Descrizione approccio (italiano per adesso)
% Calcoliamo roll e pitch valutando l'accelerazione di gravità g.
% Calcoliamo yaw con i medesimi ragionamenti fatti sul campo magnetico,
% dati pitch e roll per noti.

% Per roll e pitch, si valutano le componenti misurate in terna sensore:
%	se lungo x è diversa da 0: si ha pitch
%	se lungo y è diversa da 0: si ha roll

% Se ho 3 componenti in assi corpo del campo magnetico, come trovo il nord?
%	il vettore del campo magnetico è inclinato di un certo dip
%	(inclinazione, angolo che fa con l'orizzontale). Prendendo le sue
%	componenti sul piano tangente alla posizione locale, il vettore
%	risultante mi individua l'angolo di cui dovrei ruotare per puntare al
%	nord (voglio componente verso est nulla). Questo di fatto è il
%	-heading, ovvero il -yaw.
%	Per calcolarlo allora facciamo -atan2(mg_y/mg_x).
% Come facciamo ad avere le componenti del campo magnetico lungo x e y sul
% piano tangente all'orizzontale (allineati sul piano orizzontale). Per
% farlo, vado a prendere le grandezze in assi corpo e compenso per pitch e
% roll (non per yaw, non la conosco ed è quella che voglio trovare).
% I passi da fare sono:
%	1) prendo il vettore campo magnetico in assi corpo
%	2) lo ruoto con una matrice di rotazione intermedia data da solo roll e
%		pitch (pseudo navigation frame, allineato all'asse x Body e non 
%		all'asse x NED, cioè al nord)
%	3) calcolo quanto è disallineato il mio asse x di pseudo navigation
%		frame con quello di NED con atan2. Se voglio heading rispetto al
%		nord geografico, devo compensare anche per la declinazione
%		magnetica locale D.
%
%	Come trovare Roll e Pitch
% Per gli angoli di Roll e Pitch si lavora con la misura in assi corpo del
% campo gravitazionale g.
% Se la componente lungo x è non nulla allora si ha pitch.
% Se la componente lungo y è non nulla allora si ha roll.
% Prendendo la matrice di rotazione da nav a body e moltiplicando il
% vettore gravità g in NED ([0 0 g]^T) per questa matrice, allora si
% ottengono le componenti di accelerazione lungo i 3 assi che dovremmo
% misurare con quei valori di roll, pitch e yaw.
%		theta = -arcsin(g_x/g)	PITCH
%	ora che ho trovato theta, posso sfruttare la misura g_y o g_z per
%	trovare phi, cioè l'angolo di roll, ad esempio
%		phi = atan2(g_y/g_z)	ROLL
%
% Dalle misure del vettore "accelerazione di gravità" in body frame
% troviamo l'angolo di rollio e di beccheggio, ipotizzando che in NED
% l'accelerazione sia data solo dalla gravità).
%
% Adesso possiamo ripartire con il calcolo dell'imbardata, ovvero dello
% YAW, col metodo descritto e che richiedeva la conoscenza di pitch e roll.
% Facciamo gli stessi ragionamenti fatti con g in NED:
%	1)Prendiamo il campo magnetico mg in NED, avrà non solo la componente N
%		diversa da zero, infatti sappiamo che forma un angolo incidente non
%		nullo e non ortogonale alla superficie.
%	2)Sappiamo pitch e roll, allora ruotiamo il vettore campo magnetico da
%		Body a uno pseudo navigation frame, avente asse z (Down)
%		coincidente con quella del NED, mentre assi x e y ruotati rispetto 
%		a quelli del navigation frame di un angolo di yaw che non conosco.
%	3)Prendendo mg_x e mg_y nello pseudo navigation frame si ottiene yaw
%		come:
%			Yaw = -atan2(mg_y/mg_x)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% nota (non mi torna più):
% l'accelerometro misura -g, quindi lavoriamo con lui e non con il
% vettore di gravità g quando eguagliamo con le misure in assi corpo
% ruotate. Nel caso di z sensore verso l'alto, viene usato -g come
% [0 0 g] in ENU. Nel caso di z sensore verso il basso, viene usato -g
% come [0 0 -g] in NED.

% Prendendo la matrice di rotazione da nav a body e moltiplicando il
% vettore gravità g in NED ([0 0 g]^T) [prima era -g???]per questa matrice, 
% allora si ottengono le componenti di accelerazione lungo i 3 assi che
% dovremmo misurare con quei valori di roll, pitch e yaw.
%		theta = arcsin(g_x/g)	PITCH
%	ora che ho trovato theta, posso sfruttare la misura g_y o g_z per
%	trovare phi, cioè l'angolo di roll, ad esempio
%		phi = atan2(g_y/g_z)	ROLL

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% da notare che i valori di Yaw ottenuti così, ovvero ipotizzando che
% la misura del campo magnetico sia nulla lungo la componente est, si
% riferiscono all'angolo di cui dovremmo ruotare rispetto al Nord
% magnetico per allinearci all'orientazione della tartaruga. Volendo
% ottenerle rispetto al nord geografico, dobbiamo andare ad aggiungere
% allo Yaw il valore della declinazione magnetica, ovvero l'angolo (che
% varia da posto a posto della terra) che forma la direzione del nord
% geografico con quella del nord magnetico (angolo da geogr a mag).

% XYZ_m_mag = rotz(-D, 'deg') * XYZ_m_geogr;
% XYZ_m_geogr = rotz(-D, 'deg') * XYZ_m_mag;

% Yaw_geog = Yaw_mag + D

%% functions
% NON FATTO PER ADESSO
% accelerometer actually measures -g instead of g, so gravity field will be
% seen as: [0 0 -g]^T if accelerometer has z axis along down direction.

% minusg_NED = [0, 0, -1];
g_NED = [0, 0, 1];
Fs_filter = 0.01; 

fprintf('YPR using rotated sensor measures \n')
[yaw_2_m, yaw_2_g, pitch_2, roll_2, R_pose_2_m, R_pose_2_g]= YPR_turtle(minusg_NED, D, acc_sens, mag_sens, Fs, Fs_filter);
fprintf('YPR using rotated sensor measures once divided by their norm \n')
[yaw_2_m_norm, yaw_2_g_norm, pitch_2norm, roll_2norm, R_pose_2_m_norm, R_pose_2_g_norm]= YPR_turtle(minusg_NED, D, acc_norm_reor, mag_norm_reor, Fs, Fs_filter);

% smooth data

% Windows choice is related to AAV computation, during which, by following
% Gunner paper steps, angles are smoothed using a 2 second moving window.
% Since our sample rate is 10Hz, we need to use a 20 samples width window.

% We so have to compute:
%		smooth_values = smoothdata(values, 'movmean', 20)
n_2s = 20;
more = 50;	% 50 for 100s smooth
yaw_2_m			= smoothdata(yaw_2_m, 'movmean', more*n_2s);
yaw_2_g			= smoothdata(yaw_2_g, 'movmean', more*n_2s);
pitch_2			= smoothdata(pitch_2, 'movmean', n_2s);
roll_2			= smoothdata(roll_2, 'movmean', n_2s);

mean_yaw_2_m	= mean(yaw_2_m);

yaw_2_m_norm	= smoothdata(yaw_2_m_norm, 'movmean', more*n_2s);
yaw_2_g_norm	= smoothdata(yaw_2_g_norm, 'movmean', more*n_2s);
pitch_2norm		= smoothdata(pitch_2norm, 'movmean', n_2s);
roll_2norm		= smoothdata(roll_2norm, 'movmean', n_2s);

%% plot (version 1 commented)
% if place == 1
% 	Single_Turtle_orientation_plot
% elseif place == 2
% 	rimini_Turtle_orientation_plot
% end

%% compares version 1 and version 2 results of YPR angles (commented, only version 2 is in use)
% Yaw Pitch and Roll angles are referred to local axis (Turtle local
% reference frame).
% Version 1 local ref frame has x axis equal to version 2
% local reference frame, so we expect angle around these axis to be equal:
%		Roll1 = Roll2
%
% Version 1 local ref frame has y axis with opposite direction with respect
% to y axis of reference frame used in version 2, so we expect angle around
% these axis to be opposite:
%		Pitch1 = Pitch2
%
% Version 1 local ref frame has z axis with opposite direction with respect
% to z axis of reference frame used in version 2, so we expect angle around
% these axis to be opposite:
%		Yaw1 = Yaw2
%
% %	a) roll_ENU		=	roll_NED
% %	b) pitch_ENU	=	- pitch_NED
% %	c) yaw_ENU		=	-yaw_NED
%
% We evaluate the correctness of the two previously applied methods by
% computing error between angles obtained once considered the differences
% just stated above: if both of them give the same results, we should
% obtain zero for all the following differences:
%
% %	a) (	roll_ENU	)	-	(	roll_NED	)  =	0
% %	b) (	pitch_ENU	)	-	(	- pitch_NED )  =	0
% %	c) (	yaw_ENU		)	-	(	-yaw_NED	)  =	0

% 	diff_ENU_NED_r = roll_1 - roll_2;
% 	diff_ENU_NED_p = pitch_1 - (-pitch_2);
% 	diff_ENU_NED_y_m = yaw_1_m - (-yaw_2_m);	% magnetic
% 	diff_ENU_NED_y_g = yaw_1_g - (-yaw_2_g);	% geographic
%
% 	diff_ENU_NED_r_norm = roll_1norm - roll_2norm;
% 	diff_ENU_NED_p_norm = pitch_1norm - (-pitch_2norm);
% 	diff_ENU_NED_ym_norm = yaw_1_m_norm - (-yaw_2_m_norm);  % magnetic
% 	diff_ENU_NED_yg_norm = yaw_1_g_norm - (-yaw_2_g_norm);	% geographic
